Дополнительные задачи от менторов

[Мини-проект. После темы -> Классы и объекты. Диаграммы классов.]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Классы и объекты. Диаграммы классов." "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Создайте *solution*, который будет содержать 2 проекта: первый проект - типа *Console Application*, второй проект - типа *Class Library*.

Создайте классы в проекте *Class Library*:

-   *Item* (товар).
    -   Свойства только для чтения (инициализируются через конструктор с параметрами):
        -   серийный номер
        -   цена
        -   вес
        -   объём
        -   название
-   *Shelf* (полка).
    -   Поля:
        -   максимальная грузоподъёмность (инициализируется через конструктор с параметрами)
        -   максимальный вмещяемый объём (инициализируется через конструктор с параметрами)
        -   товар, который находится на полке (пока предполагается, что на полке может находиться только 1 товар)
    -   Методы:
        -   *bool CanAddItem(Item item)* - проверяет, можно ли положить товар на полку (учесть вес, объём товара и что полка пустая)
        -   *void Add(Item item)* - при возможности, добавляет товар на полку
-   *Rack* (Стеллаж).
    -   Поле (инициализируется через конструктор с параметром):
        -   массив полок
    -   Методы:
        -   *bool CanAddItem(Item item)* - проверяет, можно ли положить товар на стеллаж
        -   *void Add(Item item)* - при возможности, добавить товар на стеллаж

Создайте классы в проекте *Console Application*:

-   *App*
    -   Поле (инициализируется через конструктор без параметров или на месте):
        -   массив стеллажей
    -   Метод:
        -   *void Run()* - запускает приложение. Метод должен вывести меню из 2 команд: ```1. Add item``` и ```2. Exit```. Номер в начале комманды - это число, которое должен ввести пользователь, чтобы выполнить эту комманду. Если число неверное, нужно отобразить сообщение ```Invalid command```, а затем снова вывести меню. При выборе комманды ```Add item```, программа должна вывести сообщения пользователю с предложением ввести необходимые данные (серийный номер, цена, вес, объём, название) о товаре и добавить его на стеллаж. Если товар добавлен, вывести ```Item is added```, иначе ```No space for the item```. По окончанию этих двух сценариев ```Item is added```/```No space for the item``` нужно снова отобразить меню. При выборе комманды ```Exit```, приложение должно завершиться. В классе допустимо использовать свои закрытые методы.

---

{{< /expand >}}

[Мини-проект. После темы -> Наследование и полиморфизм в C#]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Наследование и полиморфизм в C#" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте *Class Library*:

Внести изменения в классах:

-   *Item*:
    -   изменить модификатор доступа для конструктора на *protected*
    -   добавить метод *virtual string ConvertToString()* - возвращает строку с информацией о товаре в формате ```{имя_класса} {имя_свойства1}: {значение_свойства1}, {имя_свойства2}: {значение_свойства2} ...```. Для получения имени класса можно использовать *GetType().Name*.
-   *Shelf*:
    -   изменить модификатор доступа для конструктора на *protected*
-   *Rack*:
    -   изменить модификатор доступа для конструктора на *protected*

Добавить новые классы:

-   Добавьте 3 - 5 классов, которые будут наследоваться от класса *Item* (пример: холодильник, микроволновка и т.д.) (лучше, чтобы некоторые классы были не прямыми потомками класса *Item*, а наследовались от других новых классов). Добавить в свои классы новые свойства. Переопределить в классах метод *string ConvertToString()*.

-   Добавьте 2 - 3 класса, которые будут наследоваться от класса *Shelf* (пример: материал полки *MetalShelf* и т.д.). У этих классов должны быть конструкторы без параметров. Для параметров, которые передаются родительскому конструктору, установите свои значения.

-   Добавьте 3 - 6 классов, которые будут наследоваться от класса *Rack* (пример: материал и размер стеллажа *MetalSmallRack* и т.д.). У этих классов должны быть конструкторы без параметров. Для параметров, которые передаются родительскому конструктору, установите свои значения.

Внесите изменения в проекте *Console Application*:

-   Добавьте класс *ItemFactory* с методом *Item Create(string type)*. Метод принимает тип товара (наследники класса *Item*) в строковом представлении и создаёт экземпляр для данного типа. Метод должен вывести пользователю сообщения с предложением ввести необходимые данные для указанного типа товара. Если параметр *type* содержит неверный тип, то нужно вернуть *null*.

-   Внести изменения в классе *App*:
        - добавить поле типа *ItemFactory* (инициализируется через конструктор без параметров или на месте).
        - изменить логику команды ```Add item```. Если товар можно добавить на склад, на экране должна появиться строка ```Do you want to add {информация_о_товаре} ? y/n```. Если пользователь ввёл ```y```, то нужно добавить товар на склад, иначе, просто вывести меню. Если введеное значение не равно ```y/n```, то нужно вывести ```Invalid command``` и снова отобразить строку ```Do you want to add {информация_о_товаре} ? y/n```. Также, если пользователь ввёл неверный тип товара, то нужно вывести ```"Invalid type of item``` и затем снова отобразить меню.

---

{{< /expand >}}

[Мини-проект. После темы -> Абстракция. Абстрактные классы и интерфейсы]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Абстракция. Абстрактные классы и интерфейсы" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте *Class Library*:

-   Добавить интерфейс *IWarehouseManager* с методами *bool CanAddItem(Item item)* и *void AddItem(Item item)*

-   Добавить класс *WarehouseManager*, который наследуется от интерфейса *IWarehouseManager*:
    - Поле (инициализируется через конструктор с параметрами):
        -   массив стеллажей
    - Методы:
        -   *bool CanAddItem(Item item)* - проверяет, можно ли положить товар на какой-либо стеллаж
        -   *void AddItem(Item item)* - добавляет товар на первый свободный стеллаж

Внесите изменения в проекте *Console Application*:

-   Добавить интерфейс *IItemFactory* с методом *Item Create(string type)*

-   Наследовать класс *ItemFactory* от интерфейса *IItemFactory*

-   Добавить интерфейс *ICommand* с методом *void Execute()*

-   Добавить класс *AddItemCommand*, который наследуется от интерфейса *ICommand*:
    - Поля (инициализируются через конструктор с параметрами):
        -   поле типа *IItemFactory*
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *void Execute()* - выполняет всю логику, которая была описана в предыдущих задачах, для команды ```Add item```

-   Добавить класс *ExitCommand*, который наследуется от интерфейса *ICommand*:
    - Метод:
        -   *void Execute()* - выполняет всю логику, которая была описана в предыдущих задачах, для команды ```Exit```. Для этого можно использовать *Environment.Exit(0)*


-   Добавить интерфейс *ICommandFactory* с методом *ICommand CreateCommand(int id)*

-   Добавить класс *CommandFactory*, который наследуется от интерфейса *ICommandFactory*:
    - Поля (инициализируются через конструктор с параметрами):
        -   поле типа *IItemFactory*
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *ICommand CreateCommand(int id)* - создаёт комманду по идентификатору. Если для идентификатора нет комманды, возвращает *null*

-   Внести изменения в классе *App*:
    -   удалить поле со стеллажами
    -   удалить поле типа *ItemFactory*
    -   добавить поле типа *ICommandFactory*
    -   добавить конструруктор с параметрами
    -   изменить метод *void Run()* так, чтобы он работал с текущими компонентами, при этом программа должна работать как и прежде
---

{{< /expand >}}

[Мини-проект. После темы -> Массивы и индексаторы]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Массивы и индексаторы" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте *Class Library*:

-   Добавить класс *RackReadOnlyCollection*:
    -   Поле (инициализируется через конструктор с параметрами):
        -   массив стеллажей
    -   Индексатор - должен возвращать стеллаж по индексу
    -   Свойство:
        -   количество стеллажей

-   Добавить в интерфейс *IWarehouseManager* метод *RackReadOnlyCollection GetRacks()*

-   Добавить в класс *Shelf* метод *string GetFullShelfInformation()*. Метод должен вернуть информацию о полке в формате:
```
Item count: {количество_товаров_на_полке}

{информация_о_товаре(если товар есть на полке)}
```

-   Добавить в класс *Rack* метод *string GetFullRackInformation()*. Метод должен вернуть информацию о стеллаже в формате:

```
Shelf count : {количество_полок_в_стеллаже}

Shelf {номер_полки(нумерация начинается с 1)} information:
{информация_о_полке}
```


Внесите изменения в проекте *Console Application*:

-   Изменить меню приложения:
```
1. Add item
2. Show rack information
3. Show information about all racks
4. Exit
```

-   Добавить в класс *ShowRackInformationCommand*, который наследуется от интерфейса *ICommand*:
    - Поле (инициализируется через конструктор с параметрами):
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *void Execute()* - выполняет логику для команды ```Show rack information```. Метод должен предложить пользователю ввести номер стеллажа (начиная с 1) и отобразить информацию для выбранного стеллажа. Если число, введеное пользователем, меньше 1 или больше, чем количество стеллажей, - вывести сообщение ```Rack with number is missing```, а затем отобразить меню.

-   Добавить в класс *ShowAllRackInformationCommand*, который наследуется от интерфейса *ICommand*:
    - Поле (инициализируется через конструктор с параметрами):
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *void Execute()* - выполняет логику для команды ```Show information about all racks```. Метод должен предложить отобразить информацию для всех стеллажей в формате:
        ```
        Rack {номер_стеллажа(нумерация начинается с 1)} information:

        {информация_о_стеллаже}
        ------------------------------
        ```

---

{{< /expand >}}

[Мини-проект. После темы -> Структуры и их разновидности]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Структуры и их разновидности" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте *Class Library*:

-   Добавить структуру *Weight*:
    -   Поле (инициализируется через конструктор с параметрами):
        -   значение веса
    -   Методы:
        -   *int CompareTo(Weight other)* - метод должен вернуть -1, если вес текущего экземпляра меньшее, чем вес экземпляра из параметра. 0 - если они равны. 1 - если вес текущего экземпляра больше.
        -   string ConvertToString() - должен вернуть строку в формате: ```{вес} kg```

-   Добавить структуру *Volume*:
    -   Поле (инициализируется через конструктор с параметрами):
        -   значение объёма
    -   Методы:
        -   *int CompareTo(Volume other)* - метод должен вернуть -1, если объём текущего экземпляра меньше, чем объём экземпляра из параметра. 0 - если они равны. 1 - если объём текущего экземпляра больше.
        -   string ConvertToString() - должен вернуть строку в формате: ```{объём} l```

-   Добавить структуру *Price*:
    -   Поле (инициализируется через конструктор с параметрами):
        -   значение цены
    -   Методы:
        -   string ConvertToString() - должен вернуть строку в формате: ```{цена} $```

-   Заменить тип свойств (цена, вес, объём) в классе *Item* на структуры, созданные выше. Также, при отображении информации о товаре, должны выводиться единицы измерения для созданных структур.

-   Заменить тип полей (вес, объём) в классе *Shelf* на структуры, созданные выше.


Внесите изменения в проекте *Console Application*:

-   Внести изменения в классы, что бы приложение работало корректно.

---

{{< /expand >}}

[Мини-проект. После темы -> Перечисления (enum)]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Перечисления (enum)" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте *Class Library*:

-   Добавить перечисление *WeightUnits* (единицы измерения веса) содержащее 2 значения: грамм и килограмм.

-   Внести изменения в структуру *Weight*:
    -   Добавить поле типа *WeightUnits* (инициализируется через конструктор с параметрами)
    -   Внести изменения в методы:
        -   *int CompareTo(Weight other)* - метод должен корректно работать для разных единиц измерений веса
        -   *string ConvertToString()* - должен вернуть строку в формате: ```{вес} {единица_измерения(g/kg)}```


Внесите изменения в проекте *Console Application*:

-   Внести изменения в класс *ItemFactory*:
    -   Внести изменения в метод *Item Create(string type)* - при вводе веса товара пользователь должен вводить единицу измерения веса (g/kg) вместе с весом (например ```25 kg```). Если пользователь ввёл вес в неверном формате, должно отобразиться сообщение ```Invalid weight format```, а затем должно быть предложено ввести вес снова.

---

{{< /expand >}}

[Мини-проект. После темы -> Универсальные шаблоны (generics) в C#]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Универсальные шаблоны (generics) в C#" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте *Class Library*:

-   Добавить класс *ReadOnlyCollection<T>*:
    -   Поле (инициализируется через конструктор с параметрами):
        -   массив экземпляров T
    -   Индексатор - должен возвращать экземпляр Т по индексу
    -   Свойство:
        -   количество элементов в массиве

-   Удалить класс *RackReadOnlyCollection*.

-   Изменить сигнатуру метода *RackReadOnlyCollection GetRacks()* на *ReadOnlyCollection<Rack> GetRacks()* в интерфейсе *IWarehouseManager*.

-   Добавить метод *static Weight Add(Weight weight1, Weight weight2)* в структуру *Weight*. Метод возвращает сумму весов двух параметров. Результат хранит вес в граммах или килограммах на ваше усмотрение.

-   Добавить метод *static Volume Add(Volume volume1, Volume volume2)* в структуру *Volume*. Метод возвращает сумму объёмов двух параметров.

-   Внести изменения в классе *Shelf*:
    -   Заменить поле с товаром на поле типа *List<Item>* (теперь предполагается, что на полке может быть несколько товаров)
    -   Добавить поле типа *Weight*, содержащее сумму весов товаров, которые уже есть на полке
    -   Добавить поле типа *Volume*, содержащее сумму объёмов товаров, которые уже есть на полке
    -   Изменить метод *bool CanAddItem(Item item)* - теперь на полке может быть сколько угодно товаров, главное, чтобы они все в сумме не привышали максимальную грузоподъёмность и максимальный вмещяемый объём полки
    -   Изменить метод *void Add(Item item)* - метод должен работать корректно с учетом изменений
    -   Изменить метод *string GetFullShelfInformation()* - метод должен вернуть информацию о всех товарах на полке

-   Добавьте делегат с сигнатурой *bool ItemPredicate(Item item)*.

-   Добавьте метод *ReadOnlyCollection<Item> GetItemsByCondition(ItemPredicate condition)* в интерфейс *IWarehouseManager*.

-   Внести изменения в классе *WarehouseManager*:
    -   Добавить поле типа List<Item> - товары, которые были добавлены на стеллажи
    -   Изменить метод *void AddItem(Item item)* - при добавлении товара на стеллаж, добавлять товар в новое поле
    -   Реализовать метод *ReadOnlyCollection<Item> GetItemsByCondition(ItemPredicate condition)* - метод должен вернуть все товары, для которых *ItemPredicate condition* возвращает *true*. Поиск делайте с помощью нового поля.

Внесите изменения в проекте *Console Application*:

-   Изменить меню приложения:
```
1. Add item
2. Show rack information
3. Show information about all racks
4. Show items by type
5. Show items by name
6. Exit
```

-   Добавить в класс *ShowItemsByTypeCommand*, который наследуется от интерфейса *ICommand*:
    - Поле (инициализируется через конструктор с параметрами):
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *void Execute()* - выполняет логику для команды ```Show items by type```. Метод должен предложить пользователю ввести тип товара и отобразить информацию о всех товарах данного типа. Если товаров данного типа нет, вывести сообщение ```Not found```.

-   Добавить в класс *ShowItemsByNameCommand*, который наследуется от интерфейса *ICommand*:
    - Поле (инициализируется через конструктор с параметрами):
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *void Execute()* - выполняет логику для команды ```Show items by name```. Метод должен предложить пользователю ввести строку, содержащую имя или часть имени товара, и отобразить информацию о всех товарах, которые содержат в имени введеную строку. Если таких товаров нет, вывести сообщение ```Not found```.

---

{{< /expand >}}
