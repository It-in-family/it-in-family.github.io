Дополнительные задачи от менторов

[Мини-проект. После темы -> Классы и объекты. Диаграммы классов.]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Классы и объекты. Диаграммы классов." "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Создайте *solution*, который будет содержать 2 проекта: первый проект - типа *Console Application*, второй проект - типа *Class Library*.

Создайте классы в проекте типа *Class Library*:

-   *Item* (товар).
    -   Свойства только для чтения (инициализируются через конструктор с параметрами):
        -   серийный номер
        -   цена
        -   вес
        -   объём
        -   название
-   *Shelf* (полка).
    -   Поля:
        -   максимальная грузоподъёмность (инициализируется через конструктор с параметрами)
        -   максимальный вмещяемый объём (инициализируется через конструктор с параметрами)
        -   товар, который находится на полке (пока предполагается, что на полке может находиться только 1 товар)
    -   Методы:
        -   *bool CanAddItem(Item item)* - проверяет, можно ли положить товар на полку (учесть вес, объём товара и что полка пустая)
        -   *void Add(Item item)* - при возможности, добавляет товар на полку
-   *Rack* (Стеллаж).
    -   Поле (инициализируется через конструктор с параметром):
        -   массив полок
    -   Методы:
        -   *bool CanAddItem(Item item)* - проверяет, можно ли положить товар на стеллаж
        -   *void Add(Item item)* - при возможности, добавить товар на стеллаж

Создайте классы в проекте типа *Console Application*:

-   *App*
    -   Поле (инициализируется через конструктор без параметров или на месте):
        -   массив стеллажей
    -   Метод:
        -   *void Run()* - запускает приложение. Метод должен вывести меню из 2 команд: ```1. Add item``` и ```2. Exit```. Номер в начале комманды - это число, которое должен ввести пользователь, чтобы выполнить эту комманду. Если число неверное, нужно отобразить сообщение ```Invalid command```, а затем снова вывести меню. При выборе комманды ```Add item```, программа должна вывести сообщения пользователю с предложением ввести необходимые данные (серийный номер, цена, вес, объём, название) о товаре и добавить его на стеллаж. Если товар добавлен, вывести ```Item is added```, иначе ```No space for the item```. По окончанию этих двух сценариев ```Item is added```/```No space for the item``` нужно снова отобразить меню. При выборе комманды ```Exit```, приложение должно завершиться. В классе допустимо использовать свои закрытые методы.

---

{{< /expand >}}

[Мини-проект. После темы -> Наследование и полиморфизм в C#]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Наследование и полиморфизм в C#" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте типа *Class Library*:

Внести изменения в классах:

-   *Item*:
    -   изменить модификатор доступа для конструктора на *protected*
    -   добавить метод *virtual string ConvertToString()* - возвращает строку с информацией о товаре в формате ```{имя_класса} {имя_свойства1}: {значение_свойства1}, {имя_свойства2}: {значение_свойства2} ...```. Для получения имени класса можно использовать *GetType().Name*.
-   *Shelf*:
    -   изменить модификатор доступа для конструктора на *protected*
-   *Rack*:
    -   изменить модификатор доступа для конструктора на *protected*

Добавить новые классы:

-   Добавьте 3 - 5 классов, которые будут наследоваться от класса *Item* (пример: холодильник, микроволновка и т.д.) (лучше, чтобы некоторые классы были не прямыми потомками класса *Item*, а наследовались от других новых классов). Добавить в свои классы новые свойства. Переопределить в классах метод *string ConvertToString()*.

-   Добавьте 2 - 3 класса, которые будут наследоваться от класса *Shelf* (пример: материал полки *MetalShelf* и т.д.). У этих классов должны быть конструкторы без параметров. Для параметров, которые передаются родительскому конструктору, установите свои значения.

-   Добавьте 3 - 6 классов, которые будут наследоваться от класса *Rack* (пример: материал и размер стеллажа *MetalSmallRack* и т.д.). У этих классов должны быть конструкторы без параметров. Для параметров, которые передаются родительскому конструктору, установите свои значения.

Внесите изменения в проекте типа *Console Application*:

-   Добавьте класс *ItemFactory* с методом *Item Create(string type)*. Метод принимает тип товара (наследники класса *Item*) в строковом представлении и создаёт экземпляр для данного типа. Метод должен вывести пользователю сообщения с предложением ввести необходимые данные для указанного типа товара. Если параметр *type* содержит неверный тип, то нужно вернуть *null*.

-   Внести изменения в классе *App*:
        - добавить поле типа *ItemFactory* (инициализируется через конструктор без параметров или на месте).
        - изменить логику команды ```Add item```. Если товар можно добавить на склад, на экране должна появиться строка ```Do you want to add {информация_о_товаре} ? y/n```. Если пользователь ввёл ```y```, то нужно добавить товар на склад, иначе, просто вывести меню. Если введеное значение не равно ```y/n```, то нужно вывести ```Invalid command``` и снова отобразить строку ```Do you want to add {информация_о_товаре} ? y/n```. Также, если пользователь ввёл неверный тип товара, то нужно вывести ```"Invalid type of item``` и затем снова отобразить меню.

---

{{< /expand >}}

[Мини-проект. После темы -> Абстракция. Абстрактные классы и интерфейсы]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Абстракция. Абстрактные классы и интерфейсы" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте типа *Class Library*:

-   Добавить интерфейс *IWarehouseManager* с методами *bool CanAddItem(Item item)* и *void AddItem(Item item)*

-   Добавить класс *WarehouseManager*, который наследуется от интерфейса *IWarehouseManager*:
    - Поле (инициализируется через конструктор с параметрами):
        -   массив стеллажей
    - Методы:
        -   *bool CanAddItem(Item item)* - проверяет, можно ли положить товар на какой-либо стеллаж
        -   *void AddItem(Item item)* - добавляет товар на первый свободный стеллаж

Внесите изменения в проекте типа *Console Application*:

-   Добавить интерфейс *IItemFactory* с методом *Item Create(string type)*

-   Наследовать класс *ItemFactory* от интерфейса *IItemFactory*

-   Добавить интерфейс *ICommand* с методом *void Execute()*

-   Добавить класс *AddItemCommand*, который наследуется от интерфейса *ICommand*:
    - Поля (инициализируются через конструктор с параметрами):
        -   поле типа *IItemFactory*
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *void Execute()* - выполняет всю логику, которая была описана в предыдущих задачах, для команды ```Add item```

-   Добавить класс *ExitCommand*, который наследуется от интерфейса *ICommand*:
    - Метод:
        -   *void Execute()* - выполняет всю логику, которая была описана в предыдущих задачах, для команды ```Exit```. Для этого можно использовать *Environment.Exit(0)*


-   Добавить интерфейс *ICommandFactory* с методом *ICommand CreateCommand(int id)*

-   Добавить класс *CommandFactory*, который наследуется от интерфейса *ICommandFactory*:
    - Поля (инициализируются через конструктор с параметрами):
        -   поле типа *IItemFactory*
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *ICommand CreateCommand(int id)* - создаёт комманду по идентификатору. Если для идентификатора нет комманды, возвращает *null*

-   Внести изменения в классе *App*:
    -   удалить поле со стеллажами
    -   удалить поле типа *ItemFactory*
    -   добавить поле типа *ICommandFactory*
    -   добавить конструруктор с параметрами
    -   изменить метод *void Run()* так, чтобы он работал с текущими компонентами, при этом программа должна работать как и прежде
---

{{< /expand >}}

[Мини-проект. После темы -> Массивы и индексаторы]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Массивы и индексаторы" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте типа *Class Library*:

-   Добавить класс *RackReadOnlyCollection*:
    -   Поле (инициализируется через конструктор с параметрами):
        -   массив стеллажей
    -   Индексатор - должен возвращать стеллаж по индексу
    -   Свойство:
        -   количество стеллажей

-   Добавить в интерфейс *IWarehouseManager* метод *RackReadOnlyCollection GetRacks()*

-   Добавить в класс *Shelf* метод *string GetFullShelfInformation()*. Метод должен вернуть информацию о полке в формате:
```
Item count: {количество_товаров_на_полке}

{информация_о_товаре(если товар есть на полке)}
```

-   Добавить в класс *Rack* метод *string GetFullRackInformation()*. Метод должен вернуть информацию о стеллаже в формате:

```
Shelf count : {количество_полок_в_стеллаже}

Shelf {номер_полки(нумерация начинается с 1)} information:
{информация_о_полке}
```


Внесите изменения в проекте типа *Console Application*:

-   Изменить меню приложения:
```
1. Add item
2. Show rack information
3. Show information about all racks
4. Exit
```

-   Добавить класс *ShowRackInformationCommand*, который наследуется от интерфейса *ICommand*:
    - Поле (инициализируется через конструктор с параметрами):
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *void Execute()* - выполняет логику для команды ```Show rack information```. Метод должен предложить пользователю ввести номер стеллажа (начиная с 1) и отобразить информацию для выбранного стеллажа. Если число, введеное пользователем, меньше 1 или больше, чем количество стеллажей, - вывести сообщение ```Rack with number is missing```, а затем отобразить меню.

-   Добавить класс *ShowAllRackInformationCommand*, который наследуется от интерфейса *ICommand*:
    - Поле (инициализируется через конструктор с параметрами):
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *void Execute()* - выполняет логику для команды ```Show information about all racks```. Метод должен предложить отобразить информацию для всех стеллажей в формате:
        ```
        Rack {номер_стеллажа(нумерация начинается с 1)} information:

        {информация_о_стеллаже}
        ------------------------------
        ```

---

{{< /expand >}}

[Мини-проект. После темы -> Структуры и их разновидности]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Структуры и их разновидности" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте типа *Class Library*:

-   Добавить структуру *Weight*:
    -   Поле (инициализируется через конструктор с параметрами):
        -   значение веса
    -   Методы:
        -   *int CompareTo(Weight other)* - метод должен вернуть -1, если вес текущего экземпляра меньшее, чем вес экземпляра из параметра. 0 - если они равны. 1 - если вес текущего экземпляра больше.
        -   string ConvertToString() - должен вернуть строку в формате: ```{вес} kg```

-   Добавить структуру *Volume*:
    -   Поле (инициализируется через конструктор с параметрами):
        -   значение объёма
    -   Методы:
        -   *int CompareTo(Volume other)* - метод должен вернуть -1, если объём текущего экземпляра меньше, чем объём экземпляра из параметра. 0 - если они равны. 1 - если объём текущего экземпляра больше.
        -   string ConvertToString() - должен вернуть строку в формате: ```{объём} l```

-   Добавить структуру *Price*:
    -   Поле (инициализируется через конструктор с параметрами):
        -   значение цены
    -   Методы:
        -   string ConvertToString() - должен вернуть строку в формате: ```{цена} $```

-   Заменить тип свойств (цена, вес, объём) в классе *Item* на структуры, созданные выше. Также, при отображении информации о товаре, должны выводиться единицы измерения для созданных структур.

-   Заменить тип полей (вес, объём) в классе *Shelf* на структуры, созданные выше.


Внесите изменения в проекте типа *Console Application*:

-   Внести изменения в классы, что бы приложение работало корректно.

---

{{< /expand >}}

[Мини-проект. После темы -> Перечисления (enum)]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Перечисления (enum)" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте типа *Class Library*:

-   Добавить перечисление *WeightUnits* (единицы измерения веса) содержащее 2 значения: грамм и килограмм.

-   Внести изменения в структуру *Weight*:
    -   Добавить поле типа *WeightUnits* (инициализируется через конструктор с параметрами)
    -   Внести изменения в методы:
        -   *int CompareTo(Weight other)* - метод должен корректно работать для разных единиц измерений веса
        -   *string ConvertToString()* - должен вернуть строку в формате: ```{вес} {единица_измерения(g/kg)}```


Внесите изменения в проекте типа *Console Application*:

-   Внести изменения в класс *ItemFactory*:
    -   Внести изменения в метод *Item Create(string type)* - при вводе веса товара пользователь должен вводить единицу измерения веса (g/kg) вместе с весом (например ```25 kg```). Если пользователь ввёл вес в неверном формате, должно отобразиться сообщение ```Invalid weight format```, а затем должно быть предложено ввести вес снова.

---

{{< /expand >}}

[Мини-проект. После темы -> Универсальные шаблоны (generics) в C#]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Универсальные шаблоны (generics) в C#" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте типа *Class Library*:

-   Добавить класс *ReadOnlyCollection< T >*:
    -   Поле (инициализируется через конструктор с параметрами):
        -   массив экземпляров T
    -   Индексатор - должен возвращать экземпляр Т по индексу
    -   Свойство:
        -   количество элементов в массиве

-   Удалить класс *RackReadOnlyCollection*.

-   Изменить сигнатуру метода *RackReadOnlyCollection GetRacks()* на *ReadOnlyCollection< Rack > GetRacks()* в интерфейсе *IWarehouseManager*.

-   Добавить метод *static Weight Add(Weight weight1, Weight weight2)* в структуру *Weight*. Метод возвращает сумму весов двух параметров. Результат хранит вес в граммах или килограммах на ваше усмотрение.

-   Добавить метод *static Volume Add(Volume volume1, Volume volume2)* в структуру *Volume*. Метод возвращает сумму объёмов двух параметров.

-   Внести изменения в классе *Shelf*:
    -   Заменить поле с товаром на поле типа *List< Item >* (теперь предполагается, что на полке может быть несколько товаров)
    -   Добавить поле типа *Weight*, содержащее сумму весов товаров, которые уже есть на полке
    -   Добавить поле типа *Volume*, содержащее сумму объёмов товаров, которые уже есть на полке
    -   Изменить метод *bool CanAddItem(Item item)* - теперь на полке может быть сколько угодно товаров, главное, чтобы они все в сумме не привышали максимальную грузоподъёмность и максимальный вмещяемый объём полки
    -   Изменить метод *void Add(Item item)* - метод должен работать корректно с учетом изменений
    -   Изменить метод *string GetFullShelfInformation()* - метод должен вернуть информацию о всех товарах на полке

-   Добавьте делегат с сигнатурой *bool ItemPredicate(Item item)*.

-   Добавьте метод *ReadOnlyCollection< Item > GetItemsByCondition(ItemPredicate condition)* в интерфейс *IWarehouseManager*.

-   Внести изменения в классе *WarehouseManager*:
    -   Добавить поле типа *List< Item >* - товары, которые были добавлены на стеллажи
    -   Изменить метод *void AddItem(Item item)* - при добавлении товара на стеллаж, добавлять товар в новое поле
    -   Реализовать метод *ReadOnlyCollection< Item > GetItemsByCondition(ItemPredicate condition)* - метод должен вернуть все товары, для которых *ItemPredicate condition* возвращает *true*. Поиск делайте с помощью нового поля.

Внесите изменения в проекте типа *Console Application*:

-   Изменить меню приложения:
```
1. Add item
2. Show rack information
3. Show information about all racks
4. Show items by type
5. Show items by name
6. Exit
```

-   Добавить класс *ShowItemsByTypeCommand*, который наследуется от интерфейса *ICommand*:
    - Поле (инициализируется через конструктор с параметрами):
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *void Execute()* - выполняет логику для команды ```Show items by type```. Метод должен предложить пользователю ввести тип товара и отобразить информацию о всех товарах данного типа. Если товаров данного типа нет, вывести сообщение ```Not found```.

-   Добавить класс *ShowItemsByNameCommand*, который наследуется от интерфейса *ICommand*:
    - Поле (инициализируется через конструктор с параметрами):
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *void Execute()* - выполняет логику для команды ```Show items by name```. Метод должен предложить пользователю ввести строку, содержащую имя или часть имени товара, и отобразить информацию о всех товарах, которые содержат в имени введеную строку. Если таких товаров нет, вывести сообщение ```Not found```.

---

{{< /expand >}}

[Мини-проект. После темы -> Потоки (threads) в C#]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Потоки (threads) в C#" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте типа *Class Library*:

-   Добавить свойство типа *Shelf* в класс *Item*.

-   Добавить метод *static Weight Diff(Weight weight1, Weight weight2)* в структуру *Weight*. Метод возвращает разницу весов двух параметров. Результат хранит вес в граммах или килограммах на ваше усмотрение.

-   Добавить метод *static Volume Diff(Volume volume1, Volume volume2)* в структуру *Volume*. Метод возвращает разницу объёмов двух параметров.

-   Изменить метод *void Add(Item item)* класса *Shelf*. После добавления товара на полку, экземпляр класса должен записать себя в свойство класса *Item*.

-   Добавить метод *void Remove(Item item)* в класс *Shelf*. Метод должен удалить товар с полки, обновить необходимые поля и удалить экземпляр класса из свойства класса *Item*.

-   Создать класс *Order* (заказ):
    -   Свойства только для чтения:
        -   идентификатор типа *Guid* (для каждого заказа должно генерироваться уникальное значение)
        -   список товаров (инициализируется через конструктор с параметрами)
    -   Методы:
        -   *string GetFullOrdeInformation()*. Метод должен вернуть информацию о заказе в формате:

```
Order ID: {идентификатор}
Item count : {количество_товаров_в_заказе}

{информация_о_товаре1}

{информация_о_товаре2}

...

{информация_о_товареN}
```

-   Добавить в интерфейс *IWarehouseManager* метод *bool CompleteOrder(Order order)*. Если все товары в заказе есть в наличии, то нужно их удалить и вернуть *true*. Если хоть одного товара нет в наличии - вернуть *false*.

-   Добавить интерфейс *IOrderManager* с методами:
    -   *void AddOrder(Order order)* - добавляет заказ в список
    -   *ReadOnlyCollection< Order > GetOrders()* - возвращает все заказы
    -   *Order TakeOrder(Guid id)* - возвращает заказ с указанным идентификатором и удаляет его из списка. Если заказа с таким идентификатором нет, то возвращает *null*.

-   Добавить класс *OrderManager*, который наследуется от интерфейса *IOrderManager*. Реализовать *OrderManager*, чтобы он был потокобезопасен, т.е., чтобы можно было работать в разных потоках и это не приводило к ошибкам.
    -   Поля (инициализируются по умолчанию):
        -   список заказов типа *List< Order >*
        -   объект блокировки типа *object*

Добавить проект типа *Class Library*. Данный проект будет содержать класс для генерации заказов.

###### Вносим изменения в предыдущий проект

-   После создания проекта, добавить в класс *WarehouseManager* метод *internal ReadOnlyCollection< Item > GetItems()*. Метод должен вернуть все товары в системе.

-   После добавления метода, подключить *namespace* *System.Runtime.CompilerServices* и добавить атрибут ```[assembly: InternalsVisibleTo("{имя нового проекта}")]``` после всех *using*. Этот атрибут позволяет проекту, который указан в аттрибуте, видеть члены класса, на котором весит этот атрибут (в данном случае *WarehouseManager*), с модификатором доступа *internal*. Это позволит использовать метод *internal ReadOnlyCollection< Item > GetItems()* в новой сборке, а для проекта типа *Console Application* он будет закрыт. [link](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.internalsvisibletoattribute?view=net-6.0)

###### Вносим изменения в новый проект

-   Добавить делегат *void OrderCreateHandler(Order order)*.

-   Добавить интерфейс *IOrderGenerator*. Интерфейс содержит событие типа *OrderCreateHandler*.

-   Добавить класс *OrderGenerator*, который наследуется от интерфейса *IOrderGenerator*:
    -   Поля:
        -   поле типа *Random* (инициализируется по умолчанию)
        -   поле типа *WarehouseManager* (инициализируется через конструктор с параметрами)
    -   Метод:
        -   *private void GenerateOrder()*. Задача этого метода - генерировать различные заказы и вызывать событие *OrderCreateHandler*, если получилось создать заказ и на событие кто-то подписан. Этот метод будет работать в отдельном потоке. В конструкторе класса нужно создать поток и передать этот метод как параметр, и сразу  запустить поток. Метод должен запустить бесконечный цикл и выполнять следующие действия в цикле:
            1.  Усыпить поток на 1 - 2 минуты. Для этого используйте класс *Random*.
            2.  Получите список всех товаров, которые есть в классе *WarehouseManager*.
            3.  Если товаров нет, то пропустить создание заказа (оператор *continue*). Если же товары есть, то создать заказ со случайным списком товаров из *WarehouseManager*. Один и тот же товар может быть в разных заказах, но не может дублироваться в одном заказе.
            4. Вызвать событие *OrderCreateHandler*, если есть подписчики на это событие.


Внесите изменения в проекте типа *Console Application*:

-   Добавить класс *OrderConveyor* и создать его экземпляр перед вызовом метода *Run* класса *App*:
    -   Поля (инициализируются через конструктор с параметрами):
        -   поле типа *IOrderGenerator*
        -   поле типа *IOrderManager*
    -   Метод:
        -   *private void AddOrder(Order order)* - метод добавляет заказ в поле типа *IOrderManager*. В конструкторе нужно подписаться этим методом на событие *OrderCreateHandler* экземпляра *IOrderGenerator*.

-   Изменить меню приложения:
```
1. Add item
2. Show rack information
3. Show information about all racks
4. Show items by type
5. Show items by name
6. Show orders
7. Complete order
8. Exit
```

-   Добавить поле типа *IOrderManager* в класс *CommandFactory*. Инициализировать поле через конструктор с параметрами.

-   Добавить класс *ShowOrdersCommand*, который наследуется от интерфейса *ICommand*:
    - Поле (инициализируется через конструктор с параметрами):
        -   поле типа *IOrderManager*
    - Метод:
        -   *void Execute()* - выполняет логику для команды ```Show orders```. Метод должен вывести информацию о всех заказах, которые еще не обработаны. Если заказов нет, вывести ```No orders```.

-   Добавить класс *CompleteOrderCommand*, который наследуется от интерфейса *ICommand*:
    - Поля (инициализируются через конструктор с параметрами):
        -   поле типа *IOrderManager*
        -   поле типа *IWarehouseManager*
    - Метод:
        -   *void Execute()* - выполняет логику для команды ```Complete order```. Пользователь должен ввести ID заказа, который нужно выполнить. Если такого заказа нет, отобразить ```Not found```. Если заказ с указанным ID есть, нужно его выполнить. Если заказ выполнен, отобразить ```Order is completed```, иначе - ```Order is not completed```. Заказ должен быть удалён из *IOrderManager* независимо от того, выполнился он или нет.

---

{{< /expand >}}

[Мини-проект. После темы -> Коллекции в C#]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Коллекции в C#" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

Внесите изменения в проекте типа *Class Library*:

-   Наследовать класс *ReadOnlyCollection< T >* от интерфейса *IEnumerable< T >*.

-   Заменить цикл *for* на *foreach* в классах, где это возможно.


Внесите изменения в проекте типа *Console Application*:

-   Заменить цикл *for* на *foreach* в классах *ShowItemsByTypeCommand*, *ShowItemsByNameCommand*, *ShowOrdersCommand* и других классах, где это возможно.

---

{{< /expand >}}

[Мини-проект. После темы -> Обработка исключений (exception)]:----------------------------------------------------------

{{< expand "Мини-проект. После темы -> Обработка исключений (exception)" "..." >}}

#### В рамках этого проекта вы будете выполнять задачи после окончания темы. Результатом выполнения задач будет мини-приложение по управлению складом. Модификаторы доступа выбирайте на своё усмотрение, если это не прописано явно. Старайтесь выдавать минимальный доступ к членам ваших классов.

---

-   Добавить проверки во всех конструкторах и методах с модификатором *public*, *protected* и *internal*, что пареметры ссылочного типа не равны *null*. Если какой-либо параметр равен *null*, то бросить *ArgumentNullException* с названием пареметра. Также, если есть параметр типа *string*, то проверить, что он не содержит пустую строку, иначе - бросить *ArgumentNullException* с названием пареметра.

-   Добавить проверку в конструкторе структуры *Price*, если параметр типа *decimal* меньше 0, то бросить *ArgumentException* с сообщением ```Price value cannot be less than 0``` и с названием пареметра.

-   Добавить проверку в конструкторе структуры *Volume*, если параметр типа *double* меньше 0, то бросить *ArgumentException* с сообщением ```Volume value cannot be less than 0``` и с названием пареметра.

-   Добавить проверку в метод *static Volume Diff(Volume volume1, Volume volume2)* структуры *Volume*, если результат выполнения операции меньше 0, то бросить *InvalidOperationException* с сообщением ```The result of the difference of two volumes is less than 0```.

-   Добавить проверку в конструкторе структуры *Weight*, если параметр типа *double* меньше 0, то бросить *ArgumentException* с сообщением ```Weight value cannot be less than 0``` и с названием пареметра.

-   Добавить проверку в метод *static Weight Diff(Weight weight1, Weight weight2)* структуры *Weight*, если результат выполнения операции меньше 0, то бросить *InvalidOperationException* с сообщением ```The result of the difference of two weights is less than 0```.

-   Добавить проверку в метод *void AddItem(Item item)* класса *Shelf*, если товар нельзя добавить на полку, то бросить *InvalidOperationException* с сообщением ```No space for the item on the shelf```.

-   Добавить проверку в метод *void AddItem(Item item)* класса *Rack*, если товар нельзя добавить на стеллаж, то бросить *InvalidOperationException* с сообщением ```No space for the item on the rack```.

-   Добавить проверку в метод *void AddItem(Item item)* класса *WarehouseManager*, если товар нельзя добавить, то бросить *InvalidOperationException* с сообщением ```No space for the item```.

-   Изменить класс *ItemFactory*. Нужно добавить проверки, если пользователь вводит некорректные данные (пустые строки; вместо ввода чисел, вводит буквы или другие некорретные символы; цена, вес или объём меньше 0). Если какой-то параметер введен некорректно - вывести сообщение, что параметр некорректен и попросить его ввести еще раз (обратить внимание на методы *string.IsNullOrWhiteSpace*, *decimal.TryParse*, *double.TryParse*, *int.TryParse*).

-   Изменить метод *void Execute()* класса *AddItemCommand*. Если пользователь ввёл пустое значение для типа товара, то нужно отобразить сообщение ```Type value is empty``` и попросить ввести значение снова.

-   Изменить метод *void Execute()* класса *CompleteOrderCommand*. Если пользователь ввёл некорректный идентификатор заказа, то нужно отобразить сообщение ```Invalid ID format``` и попросить ввести значение снова (обратить внимание на метод *Guid.TryParse*).

-   Изменить метод *void Execute()* класса *ShowItemsByNameCommand*. Если пользователь ввёл пустое значение для имени товара, то нужно отобразить сообщение ```Name value is empty``` и попросить ввести значение снова.

-   Изменить метод *void Execute()* класса *ShowItemsByTypeCommand*. Если пользователь ввёл пустое значение для типа товара, то нужно отобразить сообщение ```Type value is empty``` и попросить ввести значение снова.

-   Изменить метод *void Execute()* класса *ShowRackInformationCommand*. Если пользователь ввёл некорректный идентификатор заказа или значение меньше 1, то нужно отобразить сообщение ```Invalid rack number format``` или ```Rack number less than 1``` соответственно, и попросить ввести значение снова.

-   Добавить в метод *void Run()* класса *App* блок *try/catch*, чтобы перехватывать все исключения. Если исключение перехватывается в этом методе, то нужно отобразить его сообщение и затем отобразить меню приложения. Также добавить проверку для команды: если пользователь ввёл номер команды некорректно, то отобразить ```"Invalid command format```

---

{{< /expand >}}
